{% extends 'base.html' %}
{% block content %}
<header class="sticky top-0 bg-gray-50 z-20">
  <div class="flex items-center justify-between py-4 max-w-4xl mx-auto">
    <div class="text-2xl font-bold">{{ name }}의 블로그</div>
    <div class="flex items-center gap-3">
  <a href="{{ url_for('chat_home') }}" class="px-3 py-2 bg-green-600 text-white rounded text-sm">채팅</a>
      <a href="{{ url_for('post_new_get') }}" class="px-3 py-2 bg-blue-600 text-white rounded text-sm">글 작성</a>
      <form action="{{ url_for('logout') }}" method="post">
        <button class="px-3 py-2 bg-gray-800 text-white rounded text-sm">로그아웃</button>
      </form>
    </div>
  </div>
  <hr class="border-gray-200" />
</header>

<section class="mt-4">
  <div class="flex items-center justify-between max-w-4xl mx-auto">
    <div id="catWrap" class="overflow-x-auto pr-4">
      <div class="flex gap-2 min-w-max">
        {% set cats = ['전체','사회','경제','과학','문화','기술','환경','스포츠','생활','역사','철학','기타'] %}
        {% for c in cats %}
          <button data-cat="{{ c }}" class="cat-btn px-3 py-1 rounded-full border text-sm whitespace-nowrap {{ 'bg-gray-900 text-white' if c=='전체' else 'bg-white' }}">{{ c }}</button>
        {% endfor %}
      </div>
    </div>
    <div class="flex items-center gap-2 sticky right-0">
      <button id="searchToggle" class="px-3 py-1 rounded border text-sm whitespace-nowrap">검색</button>
      <button id="sortToggle" class="px-3 py-1 rounded border text-sm whitespace-nowrap" data-sort="new">최신순</button>
    </div>
  </div>

  <div id="searchBox" class="mt-3 hidden max-w-4xl mx-auto">
    <div class="relative">
      <input id="searchInput" type="text" placeholder="검색어를 입력하세요" class="w-full border rounded px-3 py-2 pr-12" />
      <button id="searchClear" type="button" aria-label="검색어 지우기" title="검색어 지우기"
        class="hidden absolute inset-y-0 right-2 my-auto h-10 w-10 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="h-8 w-8 mx-auto">
          <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </button>
    </div>
  </div>

  <div id="list" class="mt-4 space-y-4 max-w-4xl mx-auto"></div>
  <div id="empty" class="mt-8 text-center text-gray-500 hidden">검색 결과가 없습니다.</div>
  <div id="sentinel" class="h-8"></div>
</section>

<script>
  const listEl = document.getElementById('list');
  const emptyEl = document.getElementById('empty');
  const sentinel = document.getElementById('sentinel');
  const catBtns = Array.from(document.querySelectorAll('.cat-btn'));
  const searchToggle = document.getElementById('searchToggle');
  const sortToggle = document.getElementById('sortToggle');
  const searchBox = document.getElementById('searchBox');
  const searchInput = document.getElementById('searchInput');
  const searchClear = document.getElementById('searchClear');
  const loginUrl = "{{ url_for('login_get') }}";
  const refreshUrl = "{{ url_for('refresh') }}";

  let state = {
    category: '전체',
    q: '',
    sort: 'new',
    page: 1,
    limit: 10,
    loading: false,
    done: false,
  };
  let fetchToken = 0;
  let currentController = null;

  function highlight(text, q) {
    if (!q) return text;
    try {
      const re = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
  return text.replace(re, '<span class="bg-yellow-200 font-semibold rounded px-0.5">$1</span>');
    } catch (e) { return text; }
  }

  function renderItems(items) {
    if (state.page === 1) listEl.innerHTML = '';
    for (const it of items) {
      const title = highlight(it.title || '', state.q);
      const contents = highlight(it.contents || '', state.q);
  const el = document.createElement('a');
  el.href = `{{ url_for('post_detail', id='__ID__') }}`.replace('__ID__', it.id);
  el.target = '_self';
      el.className = 'block p-4 bg-white rounded border hover:bg-gray-50';
      el.innerHTML = `
  <div class="text-sm text-gray-500 mb-1">${it.category || ''} · ${it.date_text || ''}</div>
        <div class="font-semibold text-gray-900 line-clamp-1" style="display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden">${title}</div>
        <div class="text-gray-700 mt-1 line-clamp-2" style="display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden">${contents}</div>
      `;
      listEl.appendChild(el);
    }
  }

  async function fetchPage(reset=false) {
    const token = ++fetchToken;
    if (reset) {
      state.page = 1;
      state.done = false;
      listEl.innerHTML = '';
    } else {
      if (state.loading || state.done) return;
    }
    state.loading = true;
    // Cancel any in-flight request so only the latest input is reflected
    try { currentController && currentController.abort(); } catch (e) {}
    const controller = new AbortController();
    currentController = controller;
    const params = new URLSearchParams({
      category: state.category,
      q: state.q,
      sort: state.sort,
      page: state.page,
      limit: state.limit,
    });
    let data;
    try {
      const res = await fetchWithAutoRefresh(`{{ url_for('api_my_posts') }}?` + params.toString(), { signal: controller.signal });
      if (!res.ok) { state.loading = false; return; }
      data = await res.json();
    } catch (err) {
      // Abort or network error: ignore if aborted, else reset loading
      if (err && err.name === 'AbortError') { state.loading = false; return; }
      state.loading = false; return;
    }
    const items = data.items || [];
  const searchOpen = !searchBox.classList.contains('hidden') && state.q;
  if (token !== fetchToken) { state.loading = false; return; }
    if (state.page === 1 && items.length === 0) {
      emptyEl.textContent = searchOpen ? '검색 결과가 없습니다.' : '새로운 글을 작성해주세요.';
      emptyEl.classList.remove('hidden');
    } else {
      emptyEl.classList.add('hidden');
    }
    renderItems(items);
    if (items.length < state.limit) state.done = true;
    state.page += 1;
    state.loading = false;
  }

  // Categories
  catBtns.forEach(btn => btn.addEventListener('click', () => {
    const cat = btn.dataset.cat;
    if (cat === state.category) return; // if already selected, do nothing
    catBtns.forEach(b => {
      b.classList.remove('bg-gray-900','text-white');
      b.classList.add('bg-white');
    });
    btn.classList.remove('bg-white');
    btn.classList.add('bg-gray-900','text-white');
    state.category = cat;
    fetchPage(true);
  }));

  // Search toggle
  searchToggle.addEventListener('click', () => {
    searchBox.classList.toggle('hidden');
    const opened = !searchBox.classList.contains('hidden');
    searchToggle.textContent = opened ? '닫기' : '검색';
    if (opened) {
      searchInput.focus();
  // update clear button visibility when opened
  updateClearVisibility();
    } else {
      state.q = '';
      searchInput.value = '';
  updateClearVisibility();
      fetchPage(true);
    }
  });

  // Search input
  // Handle IME (e.g., Korean) so that filtering triggers right after composition ends,
  // and still update for non-IME input immediately with a tiny debounce to reduce fetch storms.
  let composing = false;
  searchInput.addEventListener('compositionstart', () => composing = true);
  searchInput.addEventListener('compositionend', () => {
    composing = false;
    state.q = searchInput.value.trim();
  updateClearVisibility();
    fetchPage(true);
  });

  let t;
  searchInput.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(() => {
      state.q = searchInput.value.trim();
  updateClearVisibility();
      fetchPage(true);
  }, 90);
  });

  searchInput.addEventListener('paste', () => {
    // After paste, input event will fire; ensure quick refresh
    clearTimeout(t);
    t = setTimeout(() => {
      if (composing) return;
      state.q = searchInput.value.trim();
  updateClearVisibility();
      fetchPage(true);
    }, 50);
  });

  searchInput.addEventListener('search', () => {
    // For type="search" browsers; our input is text, but keep for compatibility
    if (composing) return;
    state.q = searchInput.value.trim();
    updateClearVisibility();
    fetchPage(true);
  });

  // Clear button behavior
  function updateClearVisibility() {
    if (!searchInput) return;
    if (searchInput.value && searchInput.value.trim().length > 0) {
      searchClear.classList.remove('hidden');
    } else {
      searchClear.classList.add('hidden');
    }
  }

  searchClear?.addEventListener('click', () => {
    searchInput.value = '';
    state.q = '';
    updateClearVisibility();
    fetchPage(true);
    searchInput.focus();
  });

  // Sort toggle
  sortToggle.addEventListener('click', () => {
    state.sort = state.sort === 'new' ? 'old' : 'new';
    sortToggle.textContent = state.sort === 'new' ? '최신순' : '과거순';
    fetchPage(true);
  });

  // Infinite scroll via IntersectionObserver
  const io = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting && listEl.children.length >= (state.limit/2)) {
        fetchPage();
      }
    })
  })
  io.observe(sentinel);

  // First load
  fetchPage(true);

  // Helper: fetch with auto refresh when access token expired
  async function fetchWithAutoRefresh(url, options={}) {
    const res = await fetch(url, { credentials: 'same-origin', ...options });
    if (res.status !== 401) return res;
    let err;
    try { err = await res.json(); } catch {}
    const code = err && err.error;
    if (code === 'access_expired' || code === 'unauthorized' || code === 'invalid_token') {
      const r = await fetch(refreshUrl, { method: 'POST', credentials: 'same-origin' });
      if (r.ok) {
        // retry original
        return fetch(url, { credentials: 'same-origin', ...options });
      }
      // refresh failed -> check if expired
      try { const e = await r.json(); if (e && e.error === 'refresh_expired') {
        alert('세션이 만료되었습니다. 다시 로그인해주세요.');
        window.location.href = loginUrl; return Promise.reject(new Error('refresh_expired'));
      }} catch {}
      alert('인증이 필요합니다. 다시 로그인해주세요.');
      window.location.href = loginUrl; return Promise.reject(new Error('unauthorized'));
    }
    return res;
  }
</script>
{% endblock %}
